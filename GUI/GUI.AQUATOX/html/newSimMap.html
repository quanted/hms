<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Leaflet-WebView2 test</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <link rel="stylesheet" href="main.css" />
    <!-- Leaflet stuff -->

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js" integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
    <script src="https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js" integrity="sha384-twf8YFpk0FSzm0AmW2GRJjjnqIuQ2y86vZXh2roYI8O+kFbEBjSUDUT6U72w8shL" crossorigin="anonymous"></script>
    <!-- Load Esri Leaflet Geocoder from CDN -->

    <link rel="stylesheet" href="https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.css" integrity="sha384-29tCxPoeXnj1Eu4bPYJptxWeuI1WdrXSrGlz1J5lP6voxpJXn2f98srAoeG6KXCi" crossorigin="anonymous">
    <script src="https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.js" integrity="sha384-4LYfv8nxzrIglv5c92vOwCL7CJOPTE9QU2s7rngYvVD9JwJoz9bEnLmwZsZ8Dvgu" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-ajax/2.1.0/leaflet.ajax.min.js"
            integrity="sha512-Abr21JO2YqcJ03XGZRPuZSWKBhJpUAR6+2wH5zBeO4wAw4oksr8PRdF+BKIRsxvCdq+Mv4670rZ+dLnIyabbGw=="
            crossorigin="anonymous" "></script>

    <script src="https://unpkg.com/geojson-vt@3.2.0/geojson-vt.js"></script>
    <!-- geojson vt  -->
    <script src="JS/geojson-vt.js"></script>
    <script src="JS/leaflet-geojson-vt.js"></script>
    <script src='LPIP.js'></script>

</head>

<body>
    <div id="map_container">
        <div id="map"></div>
    </div>

    <script>
        var allShapes = null;
        var geoLayer;
        var lastFlLayer = null;
        var lastFl2Layer = null;
        var lastWBLayer = null;
        var redlayers = [];
        var redCOMIDs = [];
        var lakemode = true;
        var streammode = false;
        var oldzoom = 6;
        var AwaitSearch = false;
        var H14Zoom = false;
        var H14Selected = false;
        var LakeZoom = false;
        ZoomThresh = 9;
        LakeZoomThresh = 6;
        H14ZoomThresh = 9;

        // catchments
        const URL_NWS_WB =
            "https://mapservices.weather.noaa.gov/static/rest/services/nws_reference_maps/NWM_Lakes_and_Reservoirs/MapServer/0";
        const URL_NP21_CATCHMENTS =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0";
        // WBD - HUC_8
        const URL_NP21_HUCs =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/WBD_NP21_Simplified/MapServer/";
        // flowlines
        const URL_NP21_FLOWLINES =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer/0";

        var arcgisOnline = L.esri.Geocoding.arcgisOnlineProvider();

        // build base map layer
        var MAP = L.map("map").fitBounds([
            [49.5, -125.02],
            [23.73, -69.05]
        ]);

        var markers = L.layerGroup();

        const CenterBox = L.Control.extend({
            options: {
                position: 'bottomright'
            },
            onAdd: function (MAP) {
                return L.DomUtil.create('div', 'center-box');
            },
            setContent: function (content) {
                this.getContainer().innerHTML = 'Map Center: ' + content;
            }
        });

        var centerBox = new CenterBox().addTo(MAP);

        var geosearch = null;
        StreamSearch();

        function LakeSearch() {
            lakemode = true;
            streammode = false;
            if (lastFlLayer != null) { lastFlLayer.setStyle({ color: "blue", weight: 1 }); };
            if (lastFl2Layer != null) { lastFl2Layer.setStyle({ color: "blue", weight: 1 }); };
            ResetRedLayers();

            if (geosearch != null) geosearch.remove();
            geosearch = null;
            geosearch = L.esri.Geocoding.geosearch({
                placeholder: 'Lake/Res Name or WBCOMID',
                providers: [
                    arcgisOnline,
                    L.esri.Geocoding.mapServiceProvider({
                        label: 'Waterbodies and WBCOMIDs',
                        url: 'https://mapservices.weather.noaa.gov/static/rest/services/nws_reference_maps/NWM_Lakes_and_Reservoirs/MapServer',
                        layers: [0],
                        formatSuggestion: function (feature) {
                            return feature.properties.GNIS_NAME + ' - ' + feature.properties.feature_id; // format suggestions like this.
                        },
                        searchFields: ['GNIS_NAME', 'feature_id'],
                    })
                ]
            }).addTo(MAP);
        }

        var H14Maps = [];
        var H14Codes = [];
        var H14GeoJson = [];

        MAP.on('moveend', function () {
            if (H14Zoom && H14Selected) ShowHUC14Maps();
            centerBox.setContent(LatLngToArrayString(MAP.getCenter()));            
        });

        function ShowHUC14Maps() {
            if (!(H14Zoom && H14Selected)) {
                for (let i = 0; i < H14Codes.length; ++i) {
                    delete H14Codes[i];
                    if (H14Maps[i] != null) MAP.removeLayer(H14Maps[i]);
                    delete H14Maps[i];
                    delete H14GeoJson[i];
                };
                if (clickedHUC14) MAP.removeLayer(clickedHUC14);
                return;
            };

            var MB = MAP.getBounds();
            var E_Code = LonCode(MB.getEast());
            var W_Code = LonCode(MB.getWest());
            var S_Code = LatCode(MB.getSouth());
            var N_Code = LatCode(MB.getNorth());

            var Codes = [];
            Codes.push(E_Code + N_Code);
            Codes.push(E_Code + S_Code);
            Codes.push(W_Code + N_Code);
            Codes.push(W_Code + S_Code);

            Codes.forEach((code) => {
                if (!H14Codes.includes(code)) {
                    sendMessageToDotnet('H14' + code);   
                    H14Codes.push(code);
                }
            })

            for (let i = 0; i < H14Codes.length; ++i) {
                if (!Codes.includes(H14Codes[i])) {
                    delete H14Codes[i];
                    if (H14Maps[i] != null) MAP.removeLayer(H14Maps[i]);
                    delete H14Maps[i];
                    delete H14GeoJson[i];
                }
            }
        }


        function LonCode(lon) {
            var lonch;

            if (lon > -83.48) { lonch = "1" }
            else if (lon > -91.72) { lonch = "2" }
            else if (lon > -99.96) { lonch = "3" }
            else if (lon > -108.20) { lonch = "4" }
            else if (lon > -116.44) { lonch = "5" }
            else { lonch = "6" };

            return lonch; 
        }


        function LatCode(lat) {
            var latch;
            if (lat < 36.0) { latch = "0" }
            else if (lat < 41.5) { latch = "1" }
            else { latch = "2" }; 

            return latch;
        }


        function StreamSearch() {
            lakemode = false;
            streammode = true;
            if (lastWBLayer != null) { lastWBLayer.setStyle({ color: "blue" }); };
            if (geosearch != null) geosearch.remove();
            geosearch = null;
            geosearch = L.esri.Geocoding.geosearch({
                placeholder: 'Flowline COMID',
                providers: [
                    arcgisOnline,
                    L.esri.Geocoding.mapServiceProvider({
                        label: 'River Name and COMID',
                        url: 'https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer',
                        layers: [0],
                        formatSuggestion: function (feature) {
                            return feature.properties.GNIS_NAME + ' - ' + feature.properties.COMID;  // format suggestions like this.
                        },
                        searchFields: ['COMID'],
                    })
                ]
            }).addTo(MAP);
        }


        function LatLngToArrayString(ll) {
            return "[" + ll.lat.toFixed(5) + ", " + ll.lng.toFixed(5) + "]";
        }

        MAP.on("layeradd", function (event) {
            if (geoLayer != null) { geoLayer.bringToFront(); }
        });


        //start geojson-vt map tiles
        //interaction on the underlying polygon not drawn but represented by the tiles - they draw better
        var clickedHUC14 = null;

        MAP.on('click', function (e) {
            var x = e.latlng.lng;
            var y = e.latlng.lat;

            if ((!lakemode)&&(!streammode))
            H14GeoJson.forEach((geojsonlayer) => {
                if (geojsonlayer) {
                    var layerData = pointInLayer([x, y], geojsonlayer, true);
                    if (!layerData[0]) {
                        console.log('no HUC14 at click location');
                    } else {
                        if (clickedHUC14) {
                            clickedHUC14.setStyle({
                                color: "#4A5D23", // Reset the border color to its default color
                                weight: 1,        // Reset the border weight to its default value
                            });

                            MAP.removeLayer(clickedHUC14);
                        }

                        var highlightIndex = layerData[0].feature.properties.HUC14;
                        clickedHUC14 = new L.geoJson(geojsonlayer.toGeoJSON(), {
                            filter: function (feature, layer) {
                                return feature.properties.HUC14 == highlightIndex;
                            },
                            style: { color: 'deepskyblue', weight: 2, fillOpacity: 0.0 }  
                        });
                        bounds = clickedHUC14.getBounds();
                        if (bounds.isValid()) { 
                            clickedHUC14.addTo(MAP);
                            var attributes = highlightIndex.split('-', 2);
                            var name = attributes[0];
                            sendMessageToDotnet("HUC14|" + name);
                            var str = name + "|" + JSON.stringify(clickedHUC14.toGeoJSON());
                            sendMessageToDotnet(str);
                            MAP.fitBounds(bounds);
                        }
                    }
                }
            });
        });

        MAP.on('zoomend', function () {
            newzoom = MAP.getZoom();

            if (streammode) {
                if (newzoom <= ZoomThresh) {
                    if (oldzoom > ZoomThresh) MAP.removeLayer(FLOWLINES_LAYER);
                }
                if (newzoom > ZoomThresh) {
                    if (oldzoom <= ZoomThresh) MAP.addLayer(FLOWLINES_LAYER);
                }
            }

            if (lakemode||streammode) {
                if (newzoom <= LakeZoomThresh) {
                    if (oldzoom > LakeZoomThresh) MAP.removeLayer(WB_LAYER);
                }
                if (newzoom > LakeZoomThresh) {
                    if (oldzoom <= LakeZoomThresh) MAP.addLayer(WB_LAYER);
                }
            }

            if (newzoom < H14ZoomThresh) H14Zoom = false;
            if (newzoom >= H14ZoomThresh) {
                H14Zoom = true;  
                if (oldzoom <= H14ZoomThresh) {                    
                    ShowHUC14Maps();
                }
            }

            oldzoom = newzoom;
        });

        const LIGHT_GRAY = L.tileLayer("https://server.arcgisonline.com/arcgis/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", {
            attribution:
                'Sources: Esri, HERE, Garmin, (c) OpenStreetMap contributors, and the GIS user community',
        }).addTo(MAP);

        const NAT_GEO = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC",
            }
        );

        const SATELLITE = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            }
        );

        const Base_Maps = {
            "Black and White": LIGHT_GRAY,
            "ESRI Natl. Geo.": NAT_GEO,
            "ESRI Imagery": SATELLITE,
        };

        const WB_LAYER = L.esri
            .featureLayer({
                url: URL_NWS_WB,
                onEachFeature: WBonEachFeature
            }
            );

        function WBonEachFeature(feature, layer) {
            if (layer.feature.properties.GNIS_NAME != null) {
                var str = layer.feature.properties.GNIS_NAME.toString();
                if (str != ' ') { layer.bindTooltip(str, { opacity: 1.0 }) }
                else {
                    str = layer.feature.properties.feature_id.toString();
                    layer.bindTooltip(str, { opacity: 1.0 });
                };
            };

            layer.on('click', function (e) {
                if ((lakemode) && (layer.feature.properties.feature_id != null)) {
                    var str = "LAKE|" + layer.feature.properties.feature_id.toString() + "|";
                    if (layer.feature.properties.GNIS_NAME != null) str = str + layer.feature.properties.GNIS_NAME.toString();
                    str = str + "|";
                    if (layer.feature.properties.Shape_Area != null) str = str + layer.feature.properties.Shape_Area.toString() + "|";
                    if (lastWBLayer != null) { lastWBLayer.setStyle({ color: "blue" }); };
                    layer.setStyle({ color: "red", weight: 2 });
                    lastWBLayer = layer;
                    MAP.fitBounds(layer.getBounds());
                    sendMessageToDotnet(str);
                    str = layer.feature.properties.feature_id.toString() + "|" + JSON.stringify(layer.toGeoJSON());
                    sendMessageToDotnet(str);
                };
            });
        };

        function FLonEachFeature(feature, layer) {
            if ((feature.properties.FCODE == 56600) || (feature.properties.FLOWDIR == 0)) {
                layer.setStyle({ opacity: 0.0 });
                return;
            };

            layer.options.style.color = 'blue';
            layer.options.style.weight = 1;
            layer.setStyle({ opacity: 1.0 });
            if (redCOMIDs.length > 0)
                redCOMIDs.forEach(redCOMID => {
                    if (feature.properties.COMID == redCOMID) {
                        layer.setStyle({ weight: 2, color:'red' });
                    }
                });

            if (feature.properties.COMID != null) {
                var str = '';
                if (feature.properties.GNIS_NAME != null) str = ", " + feature.properties.GNIS_NAME.toString();
                if (str == ' ') str = '';
                str = feature.properties.COMID.toString() + str;
                layer.bindTooltip(str, { opacity: 1.0 });
            };

            layer.on('click', function (e) {
                if ((!lakemode) && (feature.properties.COMID != null)) {
                    if (lastFlLayer != null) { lastFlLayer.setStyle({ color: "blue" }); };
                    layer.setStyle({ color: "Orange", weight: 2 });
                    lastFlLayer = layer;
                    var str = "FL|" + feature.properties.COMID.toString() + "|";
                    if (feature.properties.GNIS_NAME != null) str = str + feature.properties.GNIS_NAME.toString();
                    sendMessageToDotnet(str);
                };
            });

            layer.on('contextmenu', function (e) {
                if ((!lakemode) && (layer.feature.properties.COMID != null)) {
                    if (lastFl2Layer != null) { lastFl2Layer.setStyle({ color: "blue" }); };
                    layer.setStyle({ color: "Green", weight: 2 });
                    lastFl2Layer = layer;
                    var str = "FL2|" + layer.feature.properties.COMID.toString() + "|";
                    if (layer.feature.properties.GNIS_NAME != null) str = str + layer.feature.properties.GNIS_NAME.toString();
                    sendMessageToDotnet(str);
                };
            });
        };


        // build map layers
        //            const CATCHMENTS_LAYER = L.esri
        //                .featureLayer({
        //                    url: URL_NP21_CATCHMENTS,
        //                });
        //            CATCHMENTS_LAYER.setStyle({
        //                color: "orange",
        //                fillOpacity: 0,
        //                weight: 1,
        //            });

        function createHUCLayer(url, color, defaultColor, hucLevel, onEachFeature) {
            var lastClickedHUC = null;

            function HUCClick(e) {
                if ((!lakemode) && (!streammode)) {
                    if (lastClickedHUC) {
                        lastClickedHUC.setStyle({
                            color: defaultColor, // Reset the border color to its default color
                            weight: 1,          // Reset the border weight to its default value
                        });
                    }
                    lastClickedHUC = e.layer;

                    var properties = e.layer.feature.properties;
                    var name = properties[`HUC_${hucLevel}`];
                    var desc = properties[`HU_${hucLevel}_NAME`]

                    e.layer.setStyle({
                        color: color,   // Change the border color to highlight
                        weight: 2,      // Increase the border weight for highlighting
                    });

                    MAP.fitBounds(e.layer.getBounds());
                    var str1 = `HUC${hucLevel}|${name}`;
                    if (desc !== null && desc !== undefined) {
                        str1 += "|" + desc;
                    }
                    sendMessageToDotnet(str1);

                    var str = `${name}|${JSON.stringify(e.layer.toGeoJSON())}`;
                    sendMessageToDotnet(str);
                }
            }

            const layer = L.esri.featureLayer({
                url: url,
                style: (feature) => {
                      if (!(lastClickedHUC&&(lastClickedHUC.feature === feature))) 
                         return { color: defaultColor, weight: 1, fillOpacity: 0 };
                    },
                onEachFeature: onEachFeature || null,
            });

            layer.on('click', HUCClick);

            return layer;
        }

        const HUC8 = createHUCLayer(URL_NP21_HUCs + "2", "blue", "red", 8);
        const HUC10 = createHUCLayer(URL_NP21_HUCs + "1", "blue", "maroon", 10);
        const HUC12 = createHUCLayer(URL_NP21_HUCs + "0", "red", "navy", 12);


        const FLOWLINES_LAYER = L.esri.featureLayer({
            url: URL_NP21_FLOWLINES,
            style: (feature) => {
                const isInRedLayers = redlayers.some(l => l.feature === feature);
                const isLastFlLayer = lastFlLayer && lastFlLayer.feature === feature;
                const isLastFl2Layer = lastFl2Layer && lastFl2Layer.feature === feature;

                if (!isInRedLayers && !isLastFlLayer && !isLastFl2Layer) {
                    return { color: 'blue', weight: 1 };
                }
            },
            onEachFeature: FLonEachFeature,
        });

        FLOWLINES_LAYER.setStyle({
            color: "blue",
            fillOpacity: 0,
            weight: 1,
        });

        // Event listener for when layer starts loading
        FLOWLINES_LAYER.on('loading', function () {
            // Change cursor to 'wait' when loading starts
            document.getElementById('map').style.cursor = 'wait';
        });

        // Event listener for when layer finishes loading
        FLOWLINES_LAYER.on('load', function () {
            // Revert cursor back to default when loading finishes
            document.getElementById('map').style.cursor = '';
        });


        const OVERLAY_MAPS = {
            "HUC8 Boundaries": HUC8,
            "HUC10 Boundaries": HUC10,
            "HUC12 Boundaries": HUC12,
            "Flow Lines": FLOWLINES_LAYER,
            "NWS Lake/Res": WB_LAYER,
        };

        const LAYER_OPTIONS = L.control.layers(Base_Maps, OVERLAY_MAPS);
        LAYER_OPTIONS.addTo(MAP);

        // app interaction
        function handleMapClick(e) {

        }
        MAP.on("click", handleMapClick);

        function concatGeoJSON(g1, g2) {
            return {
                "type": "FeatureCollection",
                "features": [...g1.features, ...g2.features]
            }
        }


        var greenIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });
        var redIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });

        function AddMarker(mcolor, long, lat, msg) {
            var marker;
            if (mcolor == "green") marker = L.marker([lat, long], { icon: greenIcon });
            else marker = L.marker([lat, long], { icon: redIcon });
            marker.bindTooltip(msg);
            markers.addLayer(marker);
        }

        function Bounds(showstr) {
            if (showstr == "True") MAP.addLayer(markers);
            else MAP.removeLayer(markers);
        }

        var geojsonStyle = {
            color: "#4A5D23",
            weight: 1,
            opacity: 1,
            fillOpacity: 0.01,
        };


        // app interaction
        function AddGeoJSON(gstr) {
            allShapes = JSON.parse(gstr);

            var options = {
                maxZoom: 20,
                minZoom: H14ZoomThresh,
                tolerance: 5,
                debug: 0,
                style: geojsonStyle
            };
            H14GeoJson.push(new L.GeoJSON(allShapes));
            H14Map = L.geoJson.vt(allShapes, options).addTo(MAP);
            H14Maps.push(H14Map);
            H14Map.bringToFront();

            sendMessageToDotnet('DoneDraw');
        }

        function ShowStreamDefaults() {
            newzoom = MAP.getZoom();
            if (newzoom > ZoomThresh) MAP.addLayer(FLOWLINES_LAYER);
            if (newzoom > LakeZoomThresh) MAP.addLayer(WB_LAYER);
            RemoveHUCMaps()
            FLOWLINES_LAYER.setStyle({ color: "blue", weight: 1 });
            StreamSearch();
        }

        function ShowLakeDefaults() {
            if (newzoom > LakeZoomThresh) MAP.addLayer(WB_LAYER);
            MAP.removeLayer(FLOWLINES_LAYER);
            RemoveHUCMaps()
            FLOWLINES_LAYER.setStyle({ color: "blue", weight: 1 });
            LakeSearch()
        }

        function RemoveHUCMaps() {
            MAP.removeLayer(HUC8);
            MAP.removeLayer(HUC10);
            MAP.removeLayer(HUC12);
            if (clickedHUC14) MAP.removeLayer(clickedHUC14);
            H14Selected = false;
            ShowHUC14Maps();
        }

        function ShowHUCDefaults(hucstr) {
            lakemode = false;
            streammode = false;
            MAP.removeLayer(WB_LAYER);
            MAP.removeLayer(FLOWLINES_LAYER);
            if (hucstr == "8") MAP.addLayer(HUC8); else MAP.removeLayer(HUC8);
            if (hucstr == "10") MAP.addLayer(HUC10); else MAP.removeLayer(HUC10);
            if (hucstr == "12") MAP.addLayer(HUC12); else MAP.removeLayer(HUC12);
            H14Selected = (hucstr == "14");
            ShowHUC14Maps();
            FLOWLINES_LAYER.setStyle({ color: "blue", weight: 1 });
            if (geosearch != null) geosearch.remove();
            geosearch = null;
        }

        function ShowH14(show) {
            if (show == "true") H14Selected = true;
               else H14Selected = false;
            ShowHUC14Maps();
        }


        function highlightFlowLine(COMID, lastlayer) {
            FLOWLINES_LAYER.eachFeature(function (lyr) {
                if (lyr.feature.properties.COMID == COMID) {
                    lyr.setStyle({ color: 'red', weight: 2 });
                    redlayers.push(lyr);
                    redCOMIDs.push(COMID);
                    str = COMID + "|" + JSON.stringify(lyr.toGeoJSON());
                    sendMessageToDotnet(str);
                    return;
                }

            });

            AwaitSearch = true;
            var find = L.esri.find({ url: 'https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer' });
            find.layers('0').text(COMID).fields('COMID');
            find.run(function (error, featureCollection, response) {
                if (error) { return; }
                var rl = L.geoJSON(featureCollection.features[0]);
                redlayers.push(rl);
                redCOMIDs.push(COMID);
                if (lastlayer == "True") AwaitSearch = false;
            });

        }

        function ZoomtoRedLayers() {
            if (AwaitSearch == true) {
                window.setTimeout(ZoomtoRedLayers, 100); /* this checks the flag every 100 milliseconds*/
            } else {
                var FG = L.featureGroup();
                redlayers.forEach(function (item, index) {
                    FG.addLayer(item);
                });
                MAP.fitBounds(FG.getBounds());
            }
        }

        function ResetRedLayers() {
            redlayers.forEach(function (item, index) {
                item.setStyle({ color: 'blue', weight: 1 });
            });
            redlayers = [];
            redCOMIDs = [];
        };


        // dotnet <=> js message handlers
        window.addEventListener('DOMContentLoaded', (event) => {
            window.chrome.webview.postMessage('DOMContentLoaded');
        });

        window.chrome.webview.addEventListener("message", (event) => {
            var messageArr = event.data.split("|");
            if (messageArr[0] == "MARKER") AddMarker(messageArr[1], messageArr[2], messageArr[3], messageArr[4]);
            if (messageArr[0] == "BOUNDS") Bounds(messageArr[1]);
            if (messageArr[0] == "STREAMMAP") ShowStreamDefaults();
            if (messageArr[0] == "LAKEMAP") ShowLakeDefaults();
            if (messageArr[0] == "FLCOLOR") highlightFlowLine(messageArr[1], messageArr[2]);
            if (messageArr[0] == "RESETCOLORS") ResetRedLayers();
            if (messageArr[0] == "ADD") AddGeoJSON(messageArr[1]);
            if (messageArr[0] == "ZOOM") ZoomtoRedLayers();
            if (messageArr[0] == "HUCMAP") ShowHUCDefaults(messageArr[1]);
            if (messageArr[0] == "SHOWH14") ShowH14(messageArr[1]);

            //                console.log(`message from dotnet: ${event.data}`);
            //                this.document.getElementById("message-bar").innerHTML =
            //                    event.data;
        });

        function sendMessageToDotnet(message) {
            window.chrome.webview.postMessage(message);
        }
    </script>
</body>
</html>
