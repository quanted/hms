<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Leaflet-WebView2 test</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <link rel="stylesheet" href="main.css" />
    <!-- Leaflet stuff -->

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js" integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
    <script src="https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js" integrity="sha384-twf8YFpk0FSzm0AmW2GRJjjnqIuQ2y86vZXh2roYI8O+kFbEBjSUDUT6U72w8shL" crossorigin="anonymous"></script>
    <!-- Load Esri Leaflet Geocoder from CDN -->

    <link rel="stylesheet" href="https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.css" integrity="sha384-29tCxPoeXnj1Eu4bPYJptxWeuI1WdrXSrGlz1J5lP6voxpJXn2f98srAoeG6KXCi" crossorigin="anonymous">
    <script src="https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.js" integrity="sha384-4LYfv8nxzrIglv5c92vOwCL7CJOPTE9QU2s7rngYvVD9JwJoz9bEnLmwZsZ8Dvgu" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-ajax/2.1.0/leaflet.ajax.min.js"
            integrity="sha512-Abr21JO2YqcJ03XGZRPuZSWKBhJpUAR6+2wH5zBeO4wAw4oksr8PRdF+BKIRsxvCdq+Mv4670rZ+dLnIyabbGw=="
            crossorigin="anonymous" "></script>

    <script src="https://unpkg.com/geojson-vt@3.2.0/geojson-vt.js"></script>
    <!-- geojson vt  -->
    <script src="JS/geojson-vt.js"></script>
    <script src="JS/leaflet-geojson-vt.js"></script>
    <script src='LPIP.js'></script>

</head>

<body>
    <div id="map_container">
        <div id="map"></div>
    </div>

    <script>
        // saves info about what was last clicked
        var lastFlLayer = null;
        var lastFl2Layer = null;
        var lastWBLayer = null;

        // stores the selected COMIDs
        var redlayers = [];
        var redCOMIDs = [];

        //interface mode variables
        var lakemode = true;
        var streammode = false;
        var hucnetmode = false;
        var oldzoom = 6;
        var AwaitSearch = false;

        //zooming variables and constants
        var HZoom = false;
        var LakeZoom = false;
        ZoomThresh = 9;
        LakeZoomThresh = 8;
        H14ZoomThresh = 9;
        HZoomThresh = 9;

        // catchments
        const URL_NWS_WB =
            "https://mapservices.weather.noaa.gov/static/rest/services/nws_reference_maps/NWM_Lakes_and_Reservoirs/MapServer/0";
        const URL_NP21_CATCHMENTS =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0";
        // WBD - HUC_8
        const URL_NP21_HUCs =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/WBD_NP21_Simplified/MapServer/";
        // flowlines
        const URL_NP21_FLOWLINES =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer/0";

        var arcgisOnline = L.esri.Geocoding.arcgisOnlineProvider();

        // build base map layer
        var MAP = L.map("map").fitBounds([
            [49.5, -125.02],
            [23.73, -69.05]
        ]);

        var markers = L.layerGroup();

        const CenterBox = L.Control.extend({
            options: {
                position: 'bottomright'
            },
            onAdd: function (MAP) {
                return L.DomUtil.create('div', 'center-box');
            },
            setContent: function (content) {
                this.getContainer().innerHTML = 'Map Center: ' + content;
            }
        });

        var centerBox = new CenterBox().addTo(MAP);

        var geosearch = null;
        StreamSearch();

        function LakeSearch() {
            lakemode = true;
            streammode = false;
            if (lastFlLayer != null) { lastFlLayer.setStyle({ color: "blue", weight: 1 }); };
            if (lastFl2Layer != null) { lastFl2Layer.setStyle({ color: "blue", weight: 1 }); };
            ResetRedLayers();

            if (geosearch != null) geosearch.remove();
            geosearch = null;
            geosearch = L.esri.Geocoding.geosearch({
                placeholder: 'Lake/Res Name or WBCOMID',
                providers: [
                    arcgisOnline,
                    L.esri.Geocoding.mapServiceProvider({
                        label: 'Waterbodies and WBCOMIDs',
                        url: 'https://mapservices.weather.noaa.gov/static/rest/services/nws_reference_maps/NWM_Lakes_and_Reservoirs/MapServer',
                        layers: [0],
                        formatSuggestion: function (feature) {
                            return feature.properties.GNIS_NAME + ' - ' + feature.properties.feature_id; // format suggestions like this.
                        },
                        searchFields: ['GNIS_NAME', 'feature_id'],
                    })
                ]
            }).addTo(MAP);
        }

        var HUCData = {
            '8': { selected: false, maps: [], codes: [], geoJson: [], clicked: { false: null, true: null } }, 
            '10': { selected: false, maps: [], codes: [], geoJson: [], clicked: { false: null, true: null } }, 
            '12': { selected: false, maps: [], codes: [], geoJson: [], clicked: { false: null, true: null } }, 
            '14': { selected: false, maps: [], codes: [], geoJson: [], clicked: { false: null, true: null } } 
        };

        MAP.on('moveend', function () {
            if (((HUCData['8'].selected)||hucnetmode) ||
                (HZoom && (HUCData['10'].selected || HUCData['12'].selected || HUCData['14'].selected)))
                ShowHAWQSHUCMaps();
            centerBox.setContent(LatLngToArrayString(MAP.getCenter()));            
        });

        function ShowHAWQSHUCMaps() {  // Updates the HUCMaps and HUCCodes and HUCGeoJSON based on the map bounds and which tiles are relevant

            for (let HUCLevel in HUCData) {

                if (!HUCData[HUCLevel].selected)
                    if (HUCData[HUCLevel].clicked) {
                        if (HUCData[HUCLevel].clicked[true]) MAP.removeLayer(HUCData[HUCLevel].clicked[true]);
                        if (HUCData[HUCLevel].clicked[false]) MAP.removeLayer(HUCData[HUCLevel].clicked[false]);
                    };

                keep8mode = ((HUCLevel == '8') && hucnetmode);  // show 8 for HUC Networks
                if (((!HUCData[HUCLevel].selected) && (!keep8mode)) ||
                    ((HUCData[HUCLevel].selected) && (!HZoom) && (HUCLevel != '8'))) {   //selected, but delete layer as too zoomed out
                    for (let i = 0; i < HUCData[HUCLevel].codes.length; ++i) {
                        delete HUCData[HUCLevel].codes[i];
                        if (HUCData[HUCLevel].maps[i] != null) MAP.removeLayer(HUCData[HUCLevel].maps[i]);
                        delete HUCData[HUCLevel].maps[i];
                        delete HUCData[HUCLevel].geoJson[i];
                    }
                }
                else {
                    if ((HUCData[HUCLevel].selected)||(keep8mode)) {
                        if (HUCLevel != "8") {
                            var MB = MAP.getBounds();
                            var E_Code = LonCode(MB.getEast());
                            var W_Code = LonCode(MB.getWest());
                            var S_Code = LatCode(MB.getSouth());
                            var N_Code = LatCode(MB.getNorth());

                            var Codes = [];
                            Codes.push(E_Code + N_Code);
                            Codes.push(E_Code + S_Code);
                            Codes.push(W_Code + N_Code);
                            Codes.push(W_Code + S_Code);

                            Codes.forEach((code) => {
                                if (!HUCData[HUCLevel].codes.includes(code)) {
                                    sendMessageToDotnet('H' + HUCLevel + code);
                                    HUCData[HUCLevel].codes.push(code);
                                }
                            })

                            for (let i = 0; i < HUCData[HUCLevel].codes.length; ++i) {
                                if (!Codes.includes(HUCData[HUCLevel].codes[i])) {
                                    delete HUCData[HUCLevel].codes[i];
                                    if (HUCData[HUCLevel].maps[i] != null) MAP.removeLayer(HUCData[HUCLevel].maps[i]);
                                    delete HUCData[HUCLevel].maps[i];
                                    delete HUCData[HUCLevel].geoJson[i];
                                }
                            }

                        }
                        else {   // HUCLevel = "8"
                            if (HUCData[HUCLevel].codes.length == 0) {
                                HUCData[HUCLevel].codes.push("0");
                                sendMessageToDotnet('H8');
                            }
                        }
                    }
                }
            }
        }
                

        function LonCode(lon) {
            var lonch;

            if (lon > -83.48) { lonch = "1" }
            else if (lon > -91.72) { lonch = "2" }
            else if (lon > -99.96) { lonch = "3" }
            else if (lon > -108.20) { lonch = "4" }
            else if (lon > -116.44) { lonch = "5" }
            else { lonch = "6" };

            return lonch; 
        }

        function LatCode(lat) {
            var latch;
            if (lat < 36.0) { latch = "0" }
            else if (lat < 41.5) { latch = "1" }
            else { latch = "2" }; 

            return latch;
        }


        function StreamSearch() {
            lakemode = false;
            streammode = true;
            if (lastWBLayer != null) { lastWBLayer.setStyle({ color: "blue" }); };
            if (geosearch != null) geosearch.remove();
            geosearch = null;
            geosearch = L.esri.Geocoding.geosearch({
                placeholder: 'Flowline COMID',
                providers: [
                    arcgisOnline,
                    L.esri.Geocoding.mapServiceProvider({
                        label: 'River Name and COMID',
                        url: 'https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer',
                        layers: [0],
                        formatSuggestion: function (feature) {
                            return feature.properties.GNIS_NAME + ' - ' + feature.properties.COMID;  // format suggestions like this.
                        },
                        searchFields: ['COMID'],
                    })
                ]
            }).addTo(MAP);
        }


        function LatLngToArrayString(ll) {
            return "[" + ll.lat.toFixed(5) + ", " + ll.lng.toFixed(5) + "]";
        }

//        MAP.on("layeradd", function (event) {
//            if (geoLayer != null) { geoLayer.bringToFront(); }
//        });

        MAP.on("click", function (e) {
            HUCClick(e, false);
        });
        MAP.on("contextmenu", function (e) {
            HUCClick(e, true);
        });

        function HUCClick(e, context) {  // handles a HUC click, saves clicked, sends name and JSON to DotNet, zooms or a HUC right click
            var x = e.latlng.lng;
            var y = e.latlng.lat;

            if ((!lakemode) && (!streammode)) {
                var HUCLevel = "8"
                for (let HUCL in HUCData) if (HUCData[HUCL].selected) HUCLevel = HUCL;  //determine which is primary huc layer

                if (HUCData[HUCLevel].geoJson) HUCData[HUCLevel].geoJson.forEach((geojsonlayer) => {
                    if (geojsonlayer) {
                        var layerData = pointInLayer([x, y], geojsonlayer, true);
                        if (!layerData[0]) {
                            console.log('no HUC at click location');
                        } else {
                            if (HUCData[HUCLevel].clicked) {
                                if (HUCData[HUCLevel].clicked[context]) {
                                    MAP.removeLayer(HUCData[HUCLevel].clicked[context]);
                                }
                            }

                            var highlightIndex = layerData[0].feature.properties['HUC' + HUCLevel];
                            HUCData[HUCLevel].clicked[context] = new L.geoJson(geojsonlayer.toGeoJSON(), {
                                filter: function (feature, layer) {
                                    return feature.properties['HUC' + HUCLevel] == highlightIndex;
                                },
                                style: { color: 'deepskyblue', weight: 2, fillOpacity: 0.0 }
                            });

                            bounds = HUCData[HUCLevel].clicked[context].getBounds();
                            if (bounds.isValid()) {
                                HUCData[HUCLevel].clicked[context].addTo(MAP);
                                var attributes = highlightIndex.split('-', 2);
                                var name = attributes[0];
                                var msg = "HUC";
                                if (context) msg = "RHUC";
                                sendMessageToDotnet(msg+HUCLevel+"|" + name);
                                var str = name + "|" + JSON.stringify(HUCData[HUCLevel].clicked[context].toGeoJSON());
                                sendMessageToDotnet(str);
                                MAP.fitBounds(bounds);
                            }
                        }
                    }
                });
            }
        }

        MAP.on('zoomend', function () {  // Shows or hides layers based on zoom threshold, Flowlines, WB, HUC14

            newzoom = MAP.getZoom();

            if (streammode) {
                if (newzoom <= ZoomThresh) {
                    if (oldzoom > ZoomThresh) MAP.removeLayer(FLOWLINES_LAYER);
                }
                if (newzoom > ZoomThresh) {
                    if (oldzoom <= ZoomThresh) MAP.addLayer(FLOWLINES_LAYER);
                }
            }

            if (lakemode||streammode) {
                if (newzoom <= LakeZoomThresh) {
                    if (oldzoom > LakeZoomThresh) MAP.removeLayer(WB_LAYER);
                }
                if (newzoom > LakeZoomThresh) {
                    if (oldzoom <= LakeZoomThresh) MAP.addLayer(WB_LAYER);
                }
            }

            oldHZoom = HZoom; 
            HZoom = (newzoom >= HZoomThresh);  
            if (oldHZoom!=HZoom) ShowHAWQSHUCMaps();  //did the threshold get passed

            oldzoom = newzoom;
        });

        const LIGHT_GRAY = L.tileLayer("https://server.arcgisonline.com/arcgis/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", {
            attribution:
                'Sources: Esri, HERE, Garmin, (c) OpenStreetMap contributors, and the GIS user community',
        }).addTo(MAP);

        const NAT_GEO = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC",
            }
        );

        const SATELLITE = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            }
        );

        const Base_Maps = {
            "Black and White": LIGHT_GRAY,
            "ESRI Natl. Geo.": NAT_GEO,
            "ESRI Imagery": SATELLITE,
        };

        const WB_LAYER = L.esri
            .featureLayer({
                url: URL_NWS_WB,
                onEachFeature: WBonEachFeature
            }
            );

        function WBonEachFeature(feature, layer) {   // Formatting and click handling for waterbodies, saves lastWBLayer
            if (layer.feature.properties.GNIS_NAME != null) {
                var str = layer.feature.properties.GNIS_NAME.toString();
                if (str != ' ') { layer.bindTooltip(str, { opacity: 1.0 }) }
                else {
                    str = layer.feature.properties.feature_id.toString();
                    layer.bindTooltip(str, { opacity: 1.0 });
                };
            };

            layer.on('click', function (e) {
                if ((lakemode) && (layer.feature.properties.feature_id != null)) {
                    var str = "LAKE|" + layer.feature.properties.feature_id.toString() + "|";
                    if (layer.feature.properties.GNIS_NAME != null) str = str + layer.feature.properties.GNIS_NAME.toString();
                    str = str + "|";
                    if (layer.feature.properties.Shape_Area != null) str = str + layer.feature.properties.Shape_Area.toString() + "|";
                    if (lastWBLayer != null) { lastWBLayer.setStyle({ color: "blue" }); };
                    layer.setStyle({ color: "red", weight: 2 });
                    lastWBLayer = layer;
                    MAP.fitBounds(layer.getBounds());
                    sendMessageToDotnet(str);
                    str = layer.feature.properties.feature_id.toString() + "|" + JSON.stringify(layer.toGeoJSON());
                    sendMessageToDotnet(str);
                };
            });
        };

        function FLonEachFeature(feature, layer) {  //Formatting and click handling for flow lines

            if ((feature.properties.FCODE == 56600) || (feature.properties.FLOWDIR == 0)) {
                layer.setStyle({ opacity: 0.0 });
                return;
            };

            layer.options.style.color = 'blue';
            layer.options.style.weight = 1;
            layer.setStyle({ opacity: 1.0 });
            if (redCOMIDs.length > 0)
                redCOMIDs.forEach(redCOMID => {
                    if (feature.properties.COMID == redCOMID) {
                        layer.setStyle({ weight: 2, color:'red' });
                    }
                });

            if (feature.properties.COMID != null) {
                var str = '';
                if (feature.properties.GNIS_NAME != null) str = ", " + feature.properties.GNIS_NAME.toString();
                if (str == ' ') str = '';
                str = feature.properties.COMID.toString() + str;
                layer.bindTooltip(str, { opacity: 1.0 });
            };

            layer.on('click', function (e) {
                if ((!lakemode) && (feature.properties.COMID != null)) {
                    if (lastFlLayer != null) { lastFlLayer.setStyle({ color: "blue" }); };
                    layer.setStyle({ color: "Orange", weight: 2 });
                    lastFlLayer = layer;
                    var str = "FL|" + feature.properties.COMID.toString() + "|";
                    if (feature.properties.GNIS_NAME != null) str = str + feature.properties.GNIS_NAME.toString();
                    sendMessageToDotnet(str);
                };
            });

            layer.on('contextmenu', function (e) {
                if ((!lakemode) && (layer.feature.properties.COMID != null)) {
                    if (lastFl2Layer != null) { lastFl2Layer.setStyle({ color: "blue" }); };
                    layer.setStyle({ color: "Green", weight: 2 });
                    lastFl2Layer = layer;
                    var str = "FL2|" + layer.feature.properties.COMID.toString() + "|";
                    if (layer.feature.properties.GNIS_NAME != null) str = str + layer.feature.properties.GNIS_NAME.toString();
                    sendMessageToDotnet(str);
                };
            });
        };


        // build map layers
        //            const CATCHMENTS_LAYER = L.esri
        //                .featureLayer({
        //                    url: URL_NP21_CATCHMENTS,
        //                });
        //            CATCHMENTS_LAYER.setStyle({
        //                color: "orange",
        //                fillOpacity: 0,
        //                weight: 1,
        //            });

        function createHUCLayer(url, color, defaultColor, hucLevel, onEachFeature) {

            //var lastClickedHUC = null;
            //var lastRightClickedHUC = null;

            //function HUCClick(e) {
            //    if ((!lakemode) && (!streammode)) {
            //        if (lastClickedHUC) {
            //            lastClickedHUC.setStyle({
            //                color: defaultColor, // Reset the border color to its default color
            //                weight: 1,          // Reset the border weight to its default value
            //            });
            //        }
            //        lastClickedHUC = e.layer;

            //        var properties = e.layer.feature.properties;
            //        var name = properties[`HUC_${hucLevel}`];
            //        var desc = properties[`HU_${hucLevel}_NAME`]

            //        var wgt = 2
            //        if (hucLevel == 8) { wgt = 3 }

            //        e.layer.setStyle({
            //            color: color,   // Change the border color to highlight
            //            weight: wgt,      // Increase the border weight for highlighting
            //        });

            //        MAP.fitBounds(e.layer.getBounds());
            //        var str1 = `HUC${hucLevel}|${name}`;
            //        if (desc !== null && desc !== undefined) {
            //            str1 += "|" + desc;
            //        }
            //        sendMessageToDotnet(str1);

            //        var str = `${name}|${JSON.stringify(e.layer.toGeoJSON())}`;
            //        sendMessageToDotnet(str);
            //    }
            //}

            //function HUCRightClick(e) {
            //    if ((!lakemode) && (!streammode)) {
            //        if (lastRightClickedHUC) {
            //            lastRightClickedHUC.setStyle({
            //                color: defaultColor, // Reset the border color to its default color
            //                weight: 1,          // Reset the border weight to its default value
            //            });
            //        }
            //    }
                    
            //    lastRightClickedHUC = e.layer;

            //    var properties = e.layer.feature.properties;
            //    var name = properties[`HUC_${hucLevel}`];

            //    var str = `RHUC${hucLevel}|${name}`;
            //    sendMessageToDotnet(str);

            //    var wgt = 2
            //    if (hucLevel == 8) { wgt = 3 }

            //    e.layer.setStyle({
            //        color: color,   // Change the border color to highlight
            //        weight: wgt,      // Increase the border weight for highlighting
            //    });

            //    // Prevent the default context menu from appearing
            //    e.originalEvent.preventDefault();
            //}

            var wgt = 1
            if (hucLevel == 8) { wgt = 2; }
            const layer = L.esri.featureLayer({
                url: url,
                style: (feature) => {
//                    if (!(lastClickedHUC && (lastClickedHUC.feature === feature))) {
                        return { color: defaultColor, weight: wgt, fillOpacity: 0 };
//                    }
                },
                onEachFeature: onEachFeature || null,
            });

            return layer;
        }

        const HUC8 = createHUCLayer(URL_NP21_HUCs + "2", "blue", "red", 8);
        const HUC10 = createHUCLayer(URL_NP21_HUCs + "1", "blue", "maroon", 10);
        const HUC12 = createHUCLayer(URL_NP21_HUCs + "0", "red", "navy", 12);


        const FLOWLINES_LAYER = L.esri.featureLayer({
            url: URL_NP21_FLOWLINES,
            style: (feature) => {
                const isInRedLayers = redlayers.some(l => l.feature === feature);
                const isLastFlLayer = lastFlLayer && lastFlLayer.feature === feature;
                const isLastFl2Layer = lastFl2Layer && lastFl2Layer.feature === feature;

                if (!isInRedLayers && !isLastFlLayer && !isLastFl2Layer) {
                    return { color: 'blue', weight: 1 };
                }
            },
            onEachFeature: FLonEachFeature,
        });

        FLOWLINES_LAYER.setStyle({
            color: "blue",
            fillOpacity: 0,
            weight: 1,
        });

        // Event listener for when layer starts loading
        FLOWLINES_LAYER.on('loading', function () {
            // Change cursor to 'wait' when loading starts
            document.getElementById('map').style.cursor = 'wait';
        });

        // Event listener for when layer finishes loading
        FLOWLINES_LAYER.on('load', function () {
            // Revert cursor back to default when loading finishes
            document.getElementById('map').style.cursor = '';
        });


        const OVERLAY_MAPS = {
            "USGS HUC8 Boundaries": HUC8,
            "USGS HUC10 Boundaries": HUC10,
            "USGS HUC12 Boundaries": HUC12,
            "NHD+ Flow Lines": FLOWLINES_LAYER,
            "NWS Lake/Res": WB_LAYER,
        };

        const LAYER_OPTIONS = L.control.layers(Base_Maps, OVERLAY_MAPS);
        LAYER_OPTIONS.addTo(MAP);


        function concatGeoJSON(g1, g2) {
            return {
                "type": "FeatureCollection",
                "features": [...g1.features, ...g2.features]
            }
        }


        var greenIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });
        var redIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });

        function AddMarker(mcolor, long, lat, msg) {
            var marker;
            if (mcolor == "green") marker = L.marker([lat, long], { icon: greenIcon });
            else marker = L.marker([lat, long], { icon: redIcon });
            marker.bindTooltip(msg);
            markers.addLayer(marker);
        }

        function Bounds(showstr) {
            if (showstr == "True") MAP.addLayer(markers);
            else MAP.removeLayer(markers);
        }

        var geojsonStyle = {
            color: "#4A5D23",
            weight: 1,
            opacity: 1,
            fillOpacity: 0.01,
        };

        var H8geojsonStyle = {
            color: "navy",
            weight: 1,
            opacity: 1,
            fillOpacity: 0.01,
        };


        // app interaction
        function AddGeoJSON(hlevel, gstr) {  //Adds one of the GeoJSON layers for HAWQS HUCs, bringToFront
            var allShapes = JSON.parse(gstr);

            var gstyle = geojsonStyle;
            var options = {
                maxZoom: 20,
                minZoom: HZoomThresh,
                tolerance: 5,
                debug: 0,
                style: geojsonStyle
            };

            if (hlevel == "8") {
                options.minZoom = 1;
                options.style = H8geojsonStyle;
            }

            if (hlevel == "14") {
                options.minZoom = H14ZoomThresh;
            }

            HUCData[hlevel].geoJson.push(new L.GeoJSON(allShapes));
            Hmap = L.geoJson.vt(allShapes, options).addTo(MAP);
            HUCData[hlevel].maps.push(Hmap);
            Hmap.bringToFront();

            sendMessageToDotnet('DoneDraw');
        }

        function ShowStreamDefaults() {
            newzoom = MAP.getZoom();
            if (newzoom > ZoomThresh) MAP.addLayer(FLOWLINES_LAYER);
            if (newzoom > LakeZoomThresh) MAP.addLayer(WB_LAYER);
            RemoveHUCMaps()
            FLOWLINES_LAYER.setStyle({ color: "blue", weight: 1 });
            StreamSearch();
        }

        function ShowLakeDefaults() {
            if (newzoom > LakeZoomThresh) MAP.addLayer(WB_LAYER);
            MAP.removeLayer(FLOWLINES_LAYER);
            RemoveHUCMaps()
            FLOWLINES_LAYER.setStyle({ color: "blue", weight: 1 });
            LakeSearch()
        }

        function RemoveHUCMaps() {
            MAP.removeLayer(HUC8);
            MAP.removeLayer(HUC10);
            MAP.removeLayer(HUC12);

            for (let level in HUCData) {
                HUCData[level].selected = false;
                if (HUCData[level].clicked) {
                    if (HUCData[level].clicked[true]) MAP.removeLayer(HUCData[level].clicked[true]);
                    if (HUCData[level].clicked[false]) MAP.removeLayer(HUCData[level].clicked[false]);
                }
            }

            ShowHAWQSHUCMaps();
        }

        function ShowHUCDefaults(hucstr, keep8) {
            lakemode = false;
            streammode = false;
            hucnetmode = keep8;

            MAP.removeLayer(WB_LAYER);
            MAP.removeLayer(FLOWLINES_LAYER);
            MAP.removeLayer(HUC8);
            MAP.removeLayer(HUC10);
            MAP.removeLayer(HUC12);

            HUCData['8'].selected = (hucstr == "8");
            HUCData['10'].selected = (hucstr == "10");
            HUCData['12'].selected = (hucstr == "12");
            HUCData['14'].selected = (hucstr == "14");

            ShowHAWQSHUCMaps();

            FLOWLINES_LAYER.setStyle({ color: "blue", weight: 1 });

            if (geosearch != null) {
                geosearch.remove();
            }
            geosearch = null;
        }

        function ShowH14(show) {
            if (show == "true") H14Selected = true;
               else H14Selected = false;
            ShowHAWQSHUCMaps();
        }


        function highlightHUC(HUCNAME, lastlayer) {  //  Given a HUCName, highlights the HUC, adds to redlayers, Sends name and JSON to DotNet

            var hucLevel = HUCNAME.length.toString(); // Convert length to string to match HUCData keys

            // Validate hucLevel
            if (!(hucLevel in HUCData)) {
                console.error('Invalid hucLevel: ' + hucLevel);
                return;
            }

            var hucField = 'HUC' + hucLevel; // e.g., 'HUC8', 'HUC10', 'HUC12'

            var geoJsonLayers = HUCData[hucLevel].geoJson; // Array of L.GeoJSON layers
            var foundFeature = null;
            var foundLayer = null; // stores the L.Layer corresponding to the found feature

            for (var i = 0; i < geoJsonLayers.length; i++) {
                var geoJsonLayer = geoJsonLayers[i]; 

                if (geoJsonLayer) geoJsonLayer.eachLayer(function (layer) {
                    var feature = layer.feature; 

                    if (feature && feature.properties[hucField] === HUCNAME) {
                        foundFeature = feature;
                        foundLayer = layer;
                        return; // Exit the eachLayer function
                    }
                });

                if (foundFeature) {
                    break; // Exit the outer loop as we've found our feature
                }
            }

            if (foundFeature && foundLayer) {
                // Create a GeoJSON layer from the found feature
                var rl = L.geoJSON(foundFeature, {
                    style: { color: 'red', weight: 2 }
                });

                // Add the layer to the map and bring it to the front
                rl.addTo(MAP);
                rl.bringToFront();

                // Store the layer in redlayers for later reference
                redlayers.push(rl);

                // Send HUCNAME and GeoJSON to DotNet
                var str = HUCNAME + "|" + JSON.stringify(rl.toGeoJSON());
                sendMessageToDotnet(str);
            } else {
                console.warn('No features found for HUCNAME: ' + HUCNAME);
            }

            if (lastlayer === "True") {
                AwaitSearch = false;
            }
        }


        //    var hucLevel = HUCNAME.length;


        //    // Determine the appropriate layer index based on hucLevel
        //    var layerIndex;
        //    if (hucLevel == 8) {
        //        layerIndex = '2';
        //    } else if (hucLevel == 10) {
        //        layerIndex = '1';
        //    } else if (hucLevel == 12) {
        //        layerIndex = '0';
        //    } else {
        //        console.error('Invalid hucLevel: ' + hucLevel);
        //        return;
        //    }

        //    var url = URL_NP21_HUCs + layerIndex;
        //    var hucField = 'HUC_' + hucLevel; // e.g., 'HUC_8', 'HUC_10', 'HUC_12'
        //    var whereClause = hucField + " = '" + HUCNAME + "'";
        //    var query = L.esri.query({
        //        url: url
        //    });

        //    query.where(whereClause);

        //    AwaitSearch = true;
        //    // Run the query
        //    query.run(function (error, featureCollection, response) {
        //        if (error) {
        //            console.error('Query Error:', error);
        //            return;
        //        }

        //        if (featureCollection.features.length > 0) {
        //            // Create a GeoJSON layer from the feature
        //            var rl = L.geoJSON(featureCollection.features[0], {
        //                style: { color: 'red', weight: 2 }
        //            });

        //            // Add the layer to the map and bring it to the front
        //            rl.addTo(MAP);
        //            rl.bringToFront();

        //            // Store the layer and HUCNAME for later reference
        //            redlayers.push(rl);

        //            var str = HUCNAME + "|" + JSON.stringify(rl.toGeoJSON());
        //            sendMessageToDotnet(str);
        //        } else {
        //            console.warn('No features found for HUCNAME: ' + HUCNAME);
        //        }

        //        if (lastlayer === "True") {
        //            AwaitSearch = false;
        //        }
        //    });
        //}


        function highlightFlowLine(COMID, lastlayer) {
            FLOWLINES_LAYER.eachFeature(function (lyr) {
                if (lyr.feature.properties.COMID == COMID) {
                    lyr.setStyle({ color: 'red', weight: 2 });
                    redlayers.push(lyr);
                    redCOMIDs.push(COMID);
                    str = COMID + "|" + JSON.stringify(lyr.toGeoJSON());
                    sendMessageToDotnet(str);
                    return;
                }

            });

            AwaitSearch = true;
            var find = L.esri.find({ url: 'https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer' });
            find.layers('0').text(COMID).fields('COMID');
            find.run(function (error, featureCollection, response) {
                if (error) { return; }
                var rl = L.geoJSON(featureCollection.features[0]);
                redlayers.push(rl);
                redCOMIDs.push(COMID);
                if (lastlayer == "True") AwaitSearch = false;
            });
        }

        function ZoomtoRedLayers() {
            if (AwaitSearch == true) {
                window.setTimeout(ZoomtoRedLayers, 100); /* this checks the flag every 100 milliseconds*/
            } else {
                var FG = L.featureGroup();
                redlayers.forEach(function (item, index) {
                    FG.addLayer(item);
                });
                MAP.fitBounds(FG.getBounds());
            }
        }

        function ResetRedLayers() {
            redlayers.forEach(function (layer) {
                MAP.removeLayer(layer);
            });
            redlayers = [];
            redCOMIDs = [];
        }


        // dotnet <=> js message handlers
        window.addEventListener('DOMContentLoaded', (event) => {
            window.chrome.webview.postMessage('DOMContentLoaded');
        });

        window.chrome.webview.addEventListener("message", (event) => {
            var messageArr = event.data.split("|");
            if (messageArr[0] == "MARKER") AddMarker(messageArr[1], messageArr[2], messageArr[3], messageArr[4]);
            if (messageArr[0] == "BOUNDS") Bounds(messageArr[1]);
            if (messageArr[0] == "STREAMMAP") ShowStreamDefaults();
            if (messageArr[0] == "LAKEMAP") ShowLakeDefaults();
            if (messageArr[0] == "FLCOLOR") highlightFlowLine(messageArr[1], messageArr[2]);
            if (messageArr[0] == "HUCCOLOR") highlightHUC(messageArr[1], messageArr[2]);
            if (messageArr[0] == "RESETCOLORS") ResetRedLayers();
            if (messageArr[0] == "ADD") AddGeoJSON(messageArr[1], messageArr[2]);
            if (messageArr[0] == "ZOOM") ZoomtoRedLayers();
            if (messageArr[0] == "HUCMAP") ShowHUCDefaults(messageArr[1], false);
            if (messageArr[0] == "HUCMAP2") ShowHUCDefaults(messageArr[1], true);
            if (messageArr[0] == "SHOWH14") ShowH14(messageArr[1]);

            //                console.log(`message from dotnet: ${event.data}`);
            //                this.document.getElementById("message-bar").innerHTML =
            //                    event.data;
        });

        function sendMessageToDotnet(message) {
            window.chrome.webview.postMessage(message);
        }
    </script>
</body>
</html>
